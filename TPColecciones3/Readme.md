# Trabajo practico de Colecciones 3
## LinkedList
La clase LinkedList es casi idéntica a ArrayListArrayList frente a LinkedListLa  clase  LinkedList  es  una  colección  que  puede  contener  muchos  objetos  del  mismo  tipo,  al  igual que ArrayList.La   clase   LinkedListtiene   todos   los   mismos   métodos   que   la   clase   ArrayList   porque   ambos implementan  la  interfaz  List.  Esto  significa  que  puede  agregar  elementos,  cambiar  elementos, eliminar elementos y borrar la lista de la misma manera.ArrayList  es  la  favorita  para  realizarbúsquedas  en  una  lista  y  podemos  decir  que  ArrayList  es  más rápida  para  búsquedas  que  LinkedList.  Si  tenemos  una  lista  y  lo  que  nos  importa  no  es  buscar  la información lo más rápido posible, sino que la inserción o eliminación se hagan lo más rápidamente posible, LinkedList resulta una implementación muy eficienteSin embargo, aunque la clase ArrayList y la clase LinkedList se pueden usar de la misma manera, se construyen de manera muy diferente.Cómo funciona ArrayListLa clase ArrayList tiene una matriz regular dentro de ella. Cuando se agrega un elemento, se coloca en  la  matriz.  Si  la  matriz  no  es  lo  suficientemente  grande,  se  crea  una  nueva  matriz  más  grande para reemplazar la anterior y se elimina la anterior.
### Cómo funciona LinkedListL
inkedList   almacena   sus   elementos   en   "contenedores".   La   lista   tiene   un   enlace   al   primer contenedor y cada contenedor tiene un enlace al siguiente contenedor de la lista. Para agregar un elemento  a  la  lista,  el  elemento  se  coloca  en  un  nuevo  contenedor  y  ese  contenedor  se  vincula  a uno de los otros contenedores de la lista.Cuándo usarEs mejor usar ArrayList cuando:Quieres acceder a elementos aleatorios con frecuenciaSolo necesita agregar o eliminarelementos al final de la listaEs mejor usar una LinkedList cuando:Solo usa la lista recorriéndola en lugar de acceder a elementos aleatoriosCon frecuencia es necesario agregar y eliminar elementos desde el principio o la mitad de la lista
### Métodos LinkedList
Para  muchos  casos,  ArrayList  es  más  eficiente  ya  que  es  común  necesitar  acceso  a  elementos aleatorios en la lista, pero LinkedList proporciona varios métodos para realizar ciertas operaciones de manera más eficiente:addFirst() Agrega un elemento al principio de la lista.addLast() Agrega un elemento al final de la listaremoveFirst() Elimina un elemento del principio de la lista.removeLast() Elimina un elemento del final de la listagetFirst() Obtiene el elemento al principio de la listagetLast() Obtiene el elemento al final de la listaJava HashMapEn  el  uso  de ArrayList,  se  aprendió  que  las  matrices  almacenan  elementos  como  una  colección ordenada  y  debe  acceder  a  ellos  con  un  número  de  índice  (tipo  int).  Sin  embargo,  un  HashMap almacena  elementos  en  pares  "clave  /  valor"  y  puede  acceder  a  ellos  mediante  un  índice  de  otro tipo (por ejemplo, una cadena).Un objeto se utiliza como clave (índice) para otro objeto (valor). Puede almacenar diferentes tipos: claves de cadena y valores enteros, o el mismo tipo, como: claves de cadena y valores de cadena:EjemploCree  un objeto  HashMap  llamado  capitalCities  que  almacenará  claves  de  cadena  y  valores  de cadena:
<code>import java.util.HashMap; // import the HashMap classHashMap<String, String> capitalCities = new HashMap<String, String>(); <code/>
### Agregar elementos
La  clase  HashMap  tiene  muchos  métodos  útiles.  Por  ejemplo,  para  agregarle  elementos,  use  el método put ():
  // Import the HashMap classimportjava.util.HashMap;publicclassMyClass{publicstaticvoidmain(String[]args){// Create a HashMap object called capitalCitiesHashMap<String, String>capitalCities =newHashMap<String, String>();
// Add keys and values (Country, City)capitalCities.put("England","London");capitalCities.put("Germany","Berlin");capitalCities.put("Norway","Oslo");capitalCities.put("USA","Washington DC");System.out.println(capitalCities);}}Acceder a un ítemPara acceder a un valor en el HashMap, use el método get () y consulte su clave:capitalCities.get("England");Eliminar un itemPara eliminar un elemento, utilice el método remove () y consulte la clave:capitalCities.remove("England");Para eliminar todos los elementos, utilice el método clear ():capitalCities.clear();HashMap SizecapitalCities.size();Recorrer un HashMapRecorra los elementos de un HashMap con un bucle para cada uno.Nota:  Use  el  método  keySet  ()  si  solo  desea  las  claves,  y  use  el  método  values  ()  si  solo  desea  los valores:// Print keysfor(Stringi :capitalCities.keySet()){System.out.println(i);}// Print valuesfor(Stringi :capitalCities.values()){System.out.println(i);}// Print keys and valuesfor(Stringi :capitalCities.keySet()){
System.out.println("key: "+i +" value: "+capitalCities.get(i));}La claseTreeMapes idéntica a HashMap con la salvedad que mantiene ordenado los datos por la clave.Java HashSetUn  HashSet  es  una  colección  de  elementos  donde  cada  elemento  es  único  y  se  encuentra  en  el paquete java.util:Ejemploimportjava.util.HashSet;// Import theHashSet classHashSet<String>cars =newHashSet<String>();Agregar elementosLa  clase  HashSet  tiene  muchos  métodos  útiles.  Por  ejemplo,  para  agregarle  elementos,  use  el método add ():Ejemploimportjava.util.HashSet;publicclassMyClass{publicstaticvoidmain(String[]args){HashSet<String>cars =newHashSet<String>();cars.add("Volvo");cars.add("BMW");cars.add("Ford");cars.add("BMW");cars.add("Mazda");System.out.println(cars);}}Salida por Consola:[Volvo, Mazda, Ford, BMW]Nota:  En  el  ejemplo  anterior,  aunque  BMW  se  agrega  dos  veces,  solo  aparece  una  vez  en  el conjunto porque cada elemento de un conjunto debe ser único.Comprobar si existe un artículo. Para verificar si un elemento existe en un HashSet, use el método contains ():cars.contains("Mazda");
TreeSetrealiza  todas  las  operaciones  del HashSet.  Además, mantiene  todos  los  elementos ordenados  en  su  orden  natural  o  de  acuerdo  a  como  indique  el  Comparator  que  indique  el constructo
